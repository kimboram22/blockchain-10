# Network

물리적으로 랜선이 연결되어 있어야해(추상적으로, 눈으로 볼수없어)
라우터?

`OS` - APPLICATION
Shell - SOCKET
kernel - IP, TCP  
소프트웨이 - DRIVER
하드웨어 - LAN

-> 계층
계층구조는 순서대로 진행해야해 위에서 아래로 진행해서 넘어갈때 아래부터 위로
내 피씨 애플리케이션 -> 소켓 -> 아이피 -> 드라이버 -> 랜 > 상대 피씨 랜 > 드라이버> ip,tcp > 소켓 > 애플리케이션

## 역할

hello world를 상대피씨에 보낸다고 했을때
`랜카드`의 역할은 랜선한테 아날로그식(010101)으로 전기흐름을 쏜다. 상대 피씨 랜은 받은 아날로그를 디지털로 변환(?)
`드라이버`는 010101 데이터를 번역기를 돌려서 커널에? 전달한다.

컴퓨터의 랜카드는 1개가 아니라 여러개일수있어 (무선, 유선랜선..등등)
`ip`도 주소가 여러개가 있을수있어
`tcp` 역할은 프로토콜 정의, 그내용을 소켓을 타고 애플리케이션에 보내준다.

## `OSI7계층`

1 랜카드 : physcal layer 피지컬레이어, 물리적으로 연결되어있어
2 드라이브 : data-link layer 데이터 연결해준다
3 ip : network layer
4 tcp : transport layer

5 session layer
6 presentation
7 application
1~4가지가 중요 나머지 567은 몰라도 상관없

계층마다 하는 역할을 이해하면 된다!
각 계층마다 `식별자`가 존재한다. 고유한 키값! 엄청중요함!!!!!!!
ip도 식별자가 될수있지만 ip만 식별자는아님!!!

### 식별자

- 1,2계층 : `MACaddress` 랜카드 자체에 존재하는, 바뀌지않아
- 3계층(ip) : `ipaddress` 내 컴퓨터에 부여되는, ip 번호는 바뀔수있어
  - 컴퓨터라는 단어보다 `host` 라고 말하기
  - `ip가 있는(인터넷이되는) 컴퓨터를 host라고 한다!` 안되면 그냥 pc
  - 로컬호스트 내 컴퓨터를 말한다.
  - 여기까지 1교시
- 4계층(tcp) : `port`
- application : `Process` 엑셀, 카카오톡

1~3계층은 컴퓨터에 관한
4계층은 만들면서 열리는
wsl ifconfig -a
netmask
broadcast

중요한건 mac,ip, port

## Host

네트워크가 되는 컴퓨터 (디바이스)

- HOST
  - End-Point : 호스트 도착지점
  - Switch : 그림하나 더 추가 스위칭, 라우팅 -> 공유기

라우팅 테이블 (고속도로의 이정표같은것) 을 통해서 도착지점인지 알아가는것

1에서 8에 데이터를 보낸다고했을때
같은랜선일경우,
8번의 ip주소를 확인! (맥어드레스로 잘 식별하진않아 이슈발생함 컴퓨터 바뀐다고 랜선까지 바꾸지않으니까)

엘쓰리??

hello world를 3계층까지 보낸것!!! 10:58까지
내가 데이터를 보낼떄 컴퓨터안에서 프로세스 아이디까지 다 지정해야해
카카오톡을 보내고싶을때는 카카오톡 프로그램까지 지정

프로토콜 정의

- 내가 데이터를 보낼때 약속된 규칙대로 보내는것
  예를들면 우편 보낼때 주소적고 우편번호적고~ 이런것

4계층에서 hello world 보낼떄 손실이 날수있는데
프로토콜로 지정되어있어?
데이터를 보낼때, 상대방이 받았는지 못받았는지 검증처리가 있다

나중에 구현하고 나서 실시간, 연결, 연동 이라는 단어를 빼고 말해보기
웹서버와 db를 연동했다 -> 통신이 맞는말!
통신할떄 실시간이란건 없다, 텀이있어서

a컴이랑 b컴이 통신을하려면 커넥션..
tcp - 속도보다는 안전성을 선택한것, pc끼리 연결이 되어있는지 검증까지하는
udp - 구현이 적고 난이도가 높아, 내가 데이터 손실까지 구현을 해야해 , 연결이 되있는 안됐든 그냥보내는 ??

`TCP` 11:32
A컴퓨터랑 B컴퓨터가 있을떄 A -> B 로 Hello world를 보내려고할때
바로 헬로월드를 보내는게 아니라
1먼저 하나 보내보고 b가 받았는지 확인해보고 => SYN을 주고
b에서도 a한테 2를더해서 3을 보내보고
다시 a가 4를 보내보는!!
서로서로가 통신이 되는지를 확인하고 나서 hello world를 보내
-> 쓰리웨이핸드형식?

보내는쪽 client (A컴퓨터)
받는 쪽 server (B컴퓨터)

데이터를 받을수있는쪽이 서버(어플리케이션이 돌아가고있어야한다 = 프로세스가 열려있어야해)
-> Listen 듣는상태여야해,

11:40
`3-way-handshake`
클라이언트가 SYN 1을 주고
서버는 클한테 SYN에 +1, 2 ACK 3 를 돌려주고
클라이언트는 받은걸로 확인하고 연결작업이 끝남, 그러고 서버한테 ACK를 돌려줘
서버는 ACK를 받고 확인하면 연결작업이 끝나
이제서야 Hello world를 보내는거야

내가 aws에 listen 상태라면 (내가 서버)
클라이언트는 브라우저

아이피와 포트를 외우지못하니까 도메인

apache `프로그램` 설치를 했고
코드를 받은건 프로그램이고
그걸 실행시키는 순간 프로세스에 올린거야
디폴트로 port 80
aws 방화벽 (인바운드 아웃바운드 지정해준거)
포트포워딩 : 80포트를 많이 쓰고있는고, 방화벽에 5000번을 열어서 클라이언트한테 5000번을 주고 그걸 80번에 토스해준것

nodejs 목적은 11:53
아파치같은 프로그램으로 서버를 만들기위해서
host를 만들고 , port만들고 listen 상태에서 프로세스를 올려서 데이터를 네트워크로 받고 올려주기위해서
프로세스 식별자로 port

## port

65536
0~ 65535
0~2000 규격이 지정되어있음
대부분 3000번대부터
라이브서버 5500
로컬호스트 127.0.0.1

브라우저를 통해서 데이터 통신을 한거야

내가 라이브서버를 틀었을때의 경우 (내컴퓨터 내부에서 통신을하는거야) 호스트는 로컬호스트! 그래야 데이터 공유가 된다!
서버가 라이브서버
클라이언트가 브라우저

라이브서버 하나 더 열었을때 5501 나와

`노드js는 라이브서버를 직접 만드는거야!!!!`

앞으로 노드js로 네트워크를 구축하고 4계층 `tcp` 노드js 내장 라이브러리를 사용해서 웹페이지를 만들거야
직접 서버 리슨을하고 3핸드랑 프로토콜을 구현해보고 나서 express를 할거야

중요한건 개념인데 그걸 잘하려면 코드를 이미
배열메서드. fs. buffer 익숙해야해
